'''
   MFEM example 39 (converted from ex39.cpp)

   See c++ version in the MFEM library for more detail

   Sample runs: python ex39.py
                python ex39.py -ess "Southern Boundary"
                python ex39.py -src Base

   Description:  This example code demonstrates the use of named attribute
                 sets in MFEM to specify material regions, boundary regions,
                 or source regions by name rather than attribute numbers. It
                 also demonstrates how new named attribute sets may be created
                 from arbitrary groupings of attribute numbers and used as a
                 convenient shorthand to refer to those groupings in other
                 portions of the application or through the command line.
  
                 The particular problem being solved here is nearly the same
                 as that in example 1 i.e. a simple finite element
                 discretization of the Laplace problem -Delta u = 1 with
                 homogeneous Dirichlet boundary conditions and, in this case,
                 an inhomogeneous diffusion coefficient. The diffusion
                 coefficient is given a small default value throughout the
                 domain which is increased by two separate amounts in two named
                 regions.
  
                 This example makes use of a specific input mesh, "compass.msh",
                 containing named domain and boundary regions generated by Gmsh
                 and stored in their "msh" format (version 2.2). This file
                 defines eight boundary regions corresponding to eight compass
                 headings; "ENE", "NNE", "NNW", "WSW", "SSW", "SSE", and "ESE".
                 It also defines nine domain regions; "Base", "N Even", "N Odd",
                 "W Even", "W Odd", "S Even", "S Odd", "E Even", and "E Odd".
                 These regions split the four compass pointers into two halves
                 each and also label the remaining elements as "Base". Starting
                 with these named regions we test the construction of named
                 sets as well as reading and writing these named groupings from
                 and to mesh files.
  
                 The example highlights the use of named attribute sets for
                 both subdomains and boundaries in different contexts as well
                 as basic methods to create named sets from existing attributes.

'''
import os
from os.path import expanduser, join
import numpy as np

import mfem.ser as mfem


def run(order=1,
        meshfile='',
        source_name='Rose Even',
        ess_name='Boundary',
        visualization=True):

    # 2. Read the mesh from the given mesh file. We can handle triangular,
    #    quadrilateral, tetrahedral, hexahedral, surface and volume meshes with
    #    the same code.
    
    mesh = mfem.Mesh(meshfile, 1, 1)
    dim = mesh.Dimension()

    # 3. Refine the mesh to increase the resolution. In this example we do
    #    'ref_levels' of uniform refinement. We choose 'ref_levels' to be the
    #    largest number that gives a final mesh with no more than 50,000
    #    elements.
    ref_levels = int(np.log(50000./mesh.GetNE())/np.log(2.)/dim)
    for i in range(ref_levels):
        mesh.UniformRefinement()

    # 4a. Display attribute set names contained in the initial mesh
    attr_sets = mesh.attribute_sets
    btr_attr_sets = mesh.bdr_attribute_sets
    print(attr_sets.GetAttributeSetNames())

    '''
      std::set<string> names = attr_sets.GetAttributeSetNames();
      cout << "Element Attribute Set Names: ";
      for (auto const &set_name : names)
      {
         cout << " \"" << set_name << "\"";
      }
      cout << endl;

      std::set<string> bdr_names = bdr_attr_sets.GetAttributeSetNames();
      cout << "Boundary Attribute Set Names: ";
      for (auto const &bdr_set_name : bdr_names)
      {
         cout << " \"" << bdr_set_name << "\"";
      }
      cout << endl;
    '''

    
    fec = mfem.H1_FECollection(order,  mesh.Dimension())
    fespace = mfem.FiniteElementSpace(mesh, fec)
    print('Number of finite element unknowns: ' +
          str(fespace.GetTrueVSize()))

    # 4. Extract the list of all the boundary DOFs. These will be marked as
    #    Dirichlet in order to enforce zero boundary conditions.
    boundary_dofs = mfem.intArray()
    fespace.GetBoundaryTrueDofs(boundary_dofs)

    # 5. Define the solution x as a finite element grid function in fespace. Set
    #    the initial guess to zero, which also sets the boundary conditions.
    x = mfem.GridFunction(fespace)
    x.Assign(0.0)

    # 6. Set up the linear form b(.) corresponding to the right-hand side.
    one = mfem.ConstantCoefficient(1.0)
    b = mfem.LinearForm(fespace)
    b.AddDomainIntegrator(mfem.DomainLFIntegrator(one))
    b.Assemble()

    # 7. Set up the bilinear form a(.,.) corresponding to the -Delta operator.
    a = mfem.BilinearForm(fespace)
    a.AddDomainIntegrator(mfem.DiffusionIntegrator(one))
    a.Assemble()

    # 8. Form the linear system A X = B. This includes eliminating boundary
    #    conditions, applying AMR constraints, and other transformations.
    A = mfem.SparseMatrix()
    B = mfem.Vector()
    X = mfem.Vector()
    a.FormLinearSystem(boundary_dofs, x, b, A, X, B)
    print("Size of linear system: " + str(A.Height()))

    # 9. Solve the system using PCG with symmetric Gauss-Seidel preconditioner.
    M = mfem.GSSmoother(A)
    mfem.PCG(A, M, B, X, 1, 200, 1e-12, 0.0)

    # 10. Recover the solution x as a grid function and save to file. The output
    #     can be viewed using GLVis as follows: "glvis -m mesh.mesh -g sol.gf"
    a.RecoverFEMSolution(X, b, x)
    x.Save('sol.gf')
    mesh.Save('mesh.mesh')


if __name__ == "__main__":
    from mfem.common.arg_parser import ArgParser

    parser = ArgParser(description='Ex1 (Laplace Problem)')
    parser.add_argument('-m', '--mesh',
                        default='compass.msh',
                        action='store', type=str,
                        help='Mesh file to use.')
    parser.add_argument('-o', '--order',
                        action='store', default=1, type=int,
                        help='Finite element order (polynomial degree) or -1 for isoparametric space.')
    parser.add_argument('-src', '--source-attr-name',
                        action='store', default='Rose Even', type=str,
                        help='Name of attribute set containing source.');
    parser.add_argument('-ess','--ess-attr-name',
                        action='store', default='Bondary', type=str,
                        help='Name of attribute set containing essential BC.')
    parser.add_argument('-no-vis', '--no-visualization',
                        action='store_true',
                        default=False,
                        help='Disable or disable GLVis visualization')
    
    args = parser.parse_args()
    parser.print_options(args)

    order = args.order
    meshfile = expanduser(
        join(os.path.dirname(__file__), '..', 'data', args.mesh))

    visualization= not args.no_visualization
    source_name=args.source_attr_name
    ess_name=args.ess_attr_name

    run(order=order,
        meshfile=meshfile,
        source_name=source_name,
        ess_name=ess_name,
        visualization=visualization)
